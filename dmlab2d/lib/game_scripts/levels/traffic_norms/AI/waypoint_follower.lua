---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by samin.
--- DateTime: 10/10/2022 06:59
---


local random = require 'system.random'
local aiHelper = require 'AI.avatar_ai_helper'
local maps = require 'maps'
local tables = require 'common.tables'

local WPFollower = {}
WPFollower.__index = WPFollower

-- Waypoint follower core logic
function WPFollower:waypointInterpreter(waypoint)
    local indexToWaypoints = {
        ["1"] = { 'N', 'E' },
        ["2"] = { 'N', 'W' },
        ["3"] = { 'N', 'S' },
        ["4"] = { 'S', 'E' },
        ["5"] = { 'S', 'W' },
        ["6"] = { 'E', 'W' },
        ["B"] = { 'N', 'E', 'S', 'W' },
        ["E"] = { 'E' },
        ["W"] = { 'W' },
        ["N"] = { 'N' },
        ["S"] = { 'S' }
    }
    local newOrientations = indexToWaypoints[waypoint]
    return newOrientations
end

function WPFollower:filterMove(newOrientations, orientation, walkableNeighbour, last_waypoint)
    -- MOVE FILTRATION
    -- car already branched on a previous node and cannot branch consecutively
    if (last_waypoint == 'B') then
        return { orientation }
    end
    -- remove illegal nodes
    for key, newOrientation in pairs(newOrientations) do
        local isMoveValid = false
        for tempOrientation, neighbour in pairs(walkableNeighbour) do
            if (tempOrientation == newOrientation) then
                isMoveValid = true
            end
        end
        if (not isMoveValid) then
            tables.removeValue(newOrientations, newOrientation)
        end
    end
    -- remove 180 turn
    local oppositeOrientation = {
        ['E'] = 'W',
        ['W'] = 'E',
        ['N'] = 'S',
        ['S'] = 'N'
    }
    if (#newOrientations > 1) then
        tables.removeValue(newOrientations, oppositeOrientation[orientation])
    end
    return newOrientations
end

function WPFollower:CoordinateTranslation(position, imgWidth)
    local map_coordinate = (position[2] * (imgWidth + 1)) + position[1] + 1
    return map_coordinate
end

function WPFollower:ExtractWaypoint(position, imgWidth)
    local map = maps["logic"].layout
    local map_coordinate = self:CoordinateTranslation(position, imgWidth)
    local waypoint =map:sub(map_coordinate, map_coordinate)
    if(waypoint == 'B') then
        print(tables.tostring(position))
    end
    return waypoint
end

function WPFollower:wayPointFollow(grid, piece, orientation, last_waypoint)
    -- WAYPOINT INTERPRETATION
    local me_position = grid:position(piece)
    local waypoint = self:ExtractWaypoint(me_position, 64)
    local newOrientations = self:waypointInterpreter(waypoint, orientation)

    -- FILTER MOVE
    local walkableNeighbour = aiHelper:walkable_nodes(grid, me_position, grid:layer(piece))
    newOrientations = self:filterMove(newOrientations, orientation, walkableNeighbour, last_waypoint)

    -- Car cannot follow waypoint and must find another path
    if (#newOrientations <= 0) then
        newOrientations = { 'N', 'S', 'E', 'W' }
        newOrientations = self:filterMove(newOrientations, orientation, walkableNeighbour, last_waypoint)
    end

    -- Handles error when Car blocked from all sides
    -- Indicates that no action can be taken
    if (#newOrientations <= 0) then
        return 'X','X'
    end

    -- SELECT RANDOM MOVE FROM REMAINING
    orientation = newOrientations[random:uniformInt(1, #newOrientations)]
    return orientation, waypoint
end

-- Lane Changing logic
function WPFollower:LaneChange(grid, piece, orientation, rayCastLength)
    if(rayCastLength == nil) then
        rayCastLength = 4
    end
    -- Length for which lane is checked
    local me_position = grid:position(piece)
    -- calculate direction of rayCast from orientation
    local direction = aiHelper:orientation_to_position({ 0, 0 }, orientation, rayCastLength)
    -- get offset from piece in front, ignore hit bool, piece object.
    local _, _, me_offset = grid:rayCastDirection(grid:layer(piece), me_position, direction)
    -- search walkableNeighbours for valid lanes to switch to
    local walkableNeighbour = aiHelper:walkable_nodes(grid, me_position, grid:layer(piece))
    local max_offset_dist = aiHelper:L2_distance({0,0}, me_offset)
    local selected_lane = 'X'
    for tempOrientation, position in pairs(walkableNeighbour) do
        local waypoint = self:ExtractWaypoint(position, 64)
        local newOrientations = self:waypointInterpreter(waypoint, orientation)
        if(newOrientations==nil) then
            print("nil waypoint"..waypoint)
            print(tables.tostring(position))
            break
        end
        if (#newOrientations > 2) then
            break
        end
        if (newOrientations[1] == orientation) then
            direction = aiHelper:orientation_to_position({ 0, 0 }, orientation, rayCastLength)
            local _, _, offset = grid:rayCastDirection(grid:layer(piece), position, direction)
            if (aiHelper:L2_distance({0,0}, offset) > max_offset_dist) then
                max_offset_dist = aiHelper:L2_distance({0,0}, offset)
                selected_lane = tempOrientation
            end
        end
    end
    return selected_lane
end

return WPFollower